<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://evrgardenviolet.github.io/</id>
    <title>violet</title>
    <updated>2021-12-05T03:15:10.850Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://evrgardenviolet.github.io/"/>
    <link rel="self" href="https://evrgardenviolet.github.io/atom.xml"/>
    <subtitle>This is my tenet.</subtitle>
    <logo>https://evrgardenviolet.github.io/images/avatar.png</logo>
    <icon>https://evrgardenviolet.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, violet</rights>
    <entry>
        <title type="html"><![CDATA[点分治]]></title>
        <id>https://evrgardenviolet.github.io/post/dian-fen-zhi/</id>
        <link href="https://evrgardenviolet.github.io/post/dian-fen-zhi/">
        </link>
        <updated>2021-12-05T02:36:40.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="点分治">点分治</h1>
<h2 id="树上分治">树上分治</h2>
<p>分为边分治和点分治，其中只有点分治可以保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span> 的复杂度。</p>
<h2 id="分">分！</h2>
<ol>
<li>找重心</li>
<li>找其他被分开树的重心</li>
<li>continue</li>
</ol>
<h2 id="治">治！</h2>
<ol>
<li>额...归并</li>
<li>无了</li>
</ol>
<h2 id="例题1">例题1</h2>
<p>给定一棵树，树上路径大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的路径总数有多少。</p>
<p><a href="https://www.acwing.com/problem/content/254/">树</a></p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 10010, M = N * 2;

int n, m;
int head[N], ver[M], weight[M], next_[M], tot;
bool st[N];
int p[N], q[N];

void add(int x, int y, int z)
{
    ver[tot] = y, weight[tot] = z, next_[tot] = head[x], head[x]  = tot++;
    return ;
}

int get_size(int u, int fa) // 求子树大小
{
    if (st[u]) return 0;
    int res = 1;
    for (int i = head[u]; ~i; i = next_[i])
    {
        if (ver[i] != fa) res += get_size(ver[i], u);
    }
    return res;
}

int get_wc(int u, int fa, int idx, int&amp; wc) // 求一个点，是的他的所有子树的大小不大于 n / 2
{
    if (st[u]) return 0;
    int sum = 1, ms = 0;
    for (int i = head[u]; ~i; i = next_[i])
    {
        int j = ver[i];
        if (j == fa) continue;
        int t = get_wc(j, u, idx, wc);
        ms = max(ms, t);
        sum += t;
	}
    ms = max(ms, idx - sum);
    if (ms &lt;= idx / 2) wc = u;
    return sum;
}

void get_dist(int u, int fa, int dist, int&amp; qt) // 子树中点与点之间的距离 
{
    if (st[u]) return ;
    q[qt++] = dist;
    for (int i = head[u]; ~i; i = next_[i])
    {
        if (ver[i] != fa) get_dist(ver[i], u, dist + weight[i], qt);
    }
}

int get(int a[], int k)
{
    sort(a, a + k);
    int res = 0;
    for (int i = k - 1, j = -1; i &gt;= 0; i--) 
    {
    	while(j + 1 &lt; i &amp;&amp; a[j + 1] + a[i] &lt;= m) j++;
    	j = min(j, i - 1);
    	res += j + 1;
    }
    return res;
}

int calc(int u)
{
    if (st[u]) return 0;
    int res = 0;
    get_wc(u, -1, get_size(u, -1), u);
    st[u] = true;  //删除重心 
    int pt = 0;
    for (int i = head[u]; ~i; i = next_[i])
    {
        int j = ver[i], qt = 0;
        get_dist(j, -1, weight[i], qt);
        res -= get(q, qt);
        for (int k = 0; k &lt; qt; k++)
        {
            if (q[k] &lt;= m) res ++;
            p[pt++] = q[k];
        }
    }
    res += get(p, pt);
    for (int i = head[u]; ~i; i = next_[i])
    	res += calc(ver[i]);
    return res;
}

int main()
{
	while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n || m)
	{
		memset(st, 0, sizeof st);
		memset(head, -1, sizeof head);
		tot = 0;
		for (int i = 0; i &lt; n - 1; i++)
		{
			int a, b, c;
			scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
			add(a, b, c), add(b, a, c);
		}
		printf(&quot;%d\n&quot;, calc(0));
	}
	
	return 0;
}

</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="点分治">点分治</h1>
<h2 id="树上分治">树上分治</h2>
<p>分为边分治和点分治，其中只有点分治可以保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span> 的复杂度。</p>
<h2 id="分">分！</h2>
<ol>
<li>找重心</li>
<li>找其他被分开树的重心</li>
<li>continue</li>
</ol>
<h2 id="治">治！</h2>
<ol>
<li>额...归并</li>
<li>无了</li>
</ol>
<h2 id="例题1">例题1</h2>
<p>给定一棵树，树上路径大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的路径总数有多少。</p>
<p><a href="https://www.acwing.com/problem/content/254/">树</a></p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 10010, M = N * 2;

int n, m;
int head[N], ver[M], weight[M], next_[M], tot;
bool st[N];
int p[N], q[N];

void add(int x, int y, int z)
{
    ver[tot] = y, weight[tot] = z, next_[tot] = head[x], head[x]  = tot++;
    return ;
}

int get_size(int u, int fa) // 求子树大小
{
    if (st[u]) return 0;
    int res = 1;
    for (int i = head[u]; ~i; i = next_[i])
    {
        if (ver[i] != fa) res += get_size(ver[i], u);
    }
    return res;
}

int get_wc(int u, int fa, int idx, int&amp; wc) // 求一个点，是的他的所有子树的大小不大于 n / 2
{
    if (st[u]) return 0;
    int sum = 1, ms = 0;
    for (int i = head[u]; ~i; i = next_[i])
    {
        int j = ver[i];
        if (j == fa) continue;
        int t = get_wc(j, u, idx, wc);
        ms = max(ms, t);
        sum += t;
	}
    ms = max(ms, idx - sum);
    if (ms &lt;= idx / 2) wc = u;
    return sum;
}

void get_dist(int u, int fa, int dist, int&amp; qt) // 子树中点与点之间的距离 
{
    if (st[u]) return ;
    q[qt++] = dist;
    for (int i = head[u]; ~i; i = next_[i])
    {
        if (ver[i] != fa) get_dist(ver[i], u, dist + weight[i], qt);
    }
}

int get(int a[], int k)
{
    sort(a, a + k);
    int res = 0;
    for (int i = k - 1, j = -1; i &gt;= 0; i--) 
    {
    	while(j + 1 &lt; i &amp;&amp; a[j + 1] + a[i] &lt;= m) j++;
    	j = min(j, i - 1);
    	res += j + 1;
    }
    return res;
}

int calc(int u)
{
    if (st[u]) return 0;
    int res = 0;
    get_wc(u, -1, get_size(u, -1), u);
    st[u] = true;  //删除重心 
    int pt = 0;
    for (int i = head[u]; ~i; i = next_[i])
    {
        int j = ver[i], qt = 0;
        get_dist(j, -1, weight[i], qt);
        res -= get(q, qt);
        for (int k = 0; k &lt; qt; k++)
        {
            if (q[k] &lt;= m) res ++;
            p[pt++] = q[k];
        }
    }
    res += get(p, pt);
    for (int i = head[u]; ~i; i = next_[i])
    	res += calc(ver[i]);
    return res;
}

int main()
{
	while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n || m)
	{
		memset(st, 0, sizeof st);
		memset(head, -1, sizeof head);
		tot = 0;
		for (int i = 0; i &lt; n - 1; i++)
		{
			int a, b, c;
			scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
			add(a, b, c), add(b, a, c);
		}
		printf(&quot;%d\n&quot;, calc(0));
	}
	
	return 0;
}

</code></pre>
<!-- more -->
<!-- more -->
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[闲人の题解P7919]]></title>
        <id>https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p7919/</id>
        <link href="https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p7919/">
        </link>
        <updated>2021-11-20T03:25:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="step_1-题目简述">Step_1 题目简述</h2>
<p>对于一个有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">ABC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 组成的序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 可执行如下操作：</p>
<ol>
<li>
<p>选择一个区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[l, r \right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span> 。</p>
</li>
<li>
<p>对于选择的区间而言可以将其中所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A, B, C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 中的任意一个。 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 同理。</p>
</li>
</ol>
<p>我们需要通过以上两个操作是的序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 相邻两个字符不相等， 求最小步骤和方案。</p>
<p><a href="https://www.luogu.com.cn/problem/P7919">题目传送门</a></p>
<h2 id="step_2-题目分析">Step_2 题目分析</h2>
<p>不难发现， 此题是一道标准的构造体。<br>
根据题目描述，可以发现序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 的如下性质。</p>
<ol>
<li>
<p>假设我将一个区间中的所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> ， 所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> ， 所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> ，那么区间内（除两端）原本与相邻字符不同的依然不同， 原本相同的依然相同，也就是说区间（除两端）的本质不变。</p>
</li>
<li>
<p>我们一次性最多只能使两个原本与相邻字符相同的字符变的与相邻字符不同。</p>
</li>
</ol>
<p>对于第二点而言， 需要同学们好好领悟一下（也许不用）。</p>
<h2 id="step_3-正解思路">Step_3 正解思路</h2>
<p>通过 Step_2 的两点性质，我们不难想出如下方法：</p>
<ol>
<li>
<p>我们指定两个指针 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l, r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> ， 一个指向 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 一个指向 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 。</p>
</li>
<li>
<p>当当前指针所指与两侧的字符不相等， 那么指针向中间靠拢，否则我将指针所指区间内（不包括两端）的所有字符 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 。</p>
</li>
</ol>
<p>注意，在移动指针时不要其中一个找到目标字符就马上变换区间，因为我们要使步数最小， 所以每次尽量两个一起变。<br>
(PS. 特别注意指针最后一刻的状态， 极为容易出错）</p>
<h2 id="ac-code">AC Code</h2>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 5e3 + 5;

char s[N];
bool map[N];

int tot;
int p1[N], p2[N];
char pr[N][4];

int main(){
	int n;
	cin &gt;&gt; n;
	for (int i = 1; i &lt;= n; i++)
	{
		char ch;
		cin &gt;&gt; ch;
		s[i] = ch;
		if (s[i] == s[i - 1] &amp;&amp; i != 1) {
			map[i - 1] = 1;
			map[i] = 1;
		}
	}
	int l = 1, r = n;
	while(l &lt; r)
	{
		if (s[l] != s[l + 1]) 
		{
			l++;
			continue;
		}
		if (s[r] != s[r - 1]){
			r--;
			continue;
		} 
		if (l == r - 1){
			if (s[l] != 'A' &amp;&amp; s[r + 1] != 'A')
			{
				p1[++tot] = r;
				p2[tot] = r;
				pr[tot][0] = 'A';
				pr[tot][1] = 'A';
				pr[tot][2] = 'A';
				break;
			}
			if (s[l] != 'B' &amp;&amp; s[r + 1] != 'B')
			{
				p1[++tot] = r;
				p2[tot] = r;
				pr[tot][0] = 'B';
				pr[tot][1] = 'B';
				pr[tot][2] = 'B';
				break;
			}
			if (s[l] != 'C' &amp;&amp; s[r + 1] != 'C')
			{
				p1[++tot] = r;
				p2[tot] = r;
				pr[tot][0] = 'C';
				pr[tot][1] = 'C';
				pr[tot][2] = 'C';
				break;
			}
		}
		
		p1[++tot] = l + 1;
		p2[tot] = r - 1;
		pr[tot]['A' - 65] = 'B';
		pr[tot]['B' - 65] = 'C';
		pr[tot]['C' - 65] = 'A';
		for (int i = l + 1; i &lt;= r - 1; i++) s[i] = pr[tot][s[i] - 65];
	}
	printf(&quot;%d\n&quot;, tot);
	for (int i = 1; i &lt;= tot; i++)
	{
		printf(&quot;%d %d &quot;, p1[i], p2[i]);
		for (int j = 0; j &lt; 3; j++) printf(&quot;%c&quot;, pr[i][j]);
		puts(&quot;&quot;);
	}
	return 0;
}
</code></pre>
<h2 id="后记">后记</h2>
<p>月赛唯一一道作对的题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[闲人の题解 P7878]]></title>
        <id>https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p7878/</id>
        <link href="https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p7878/">
        </link>
        <updated>2021-11-20T03:23:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="step1题目简化粗略分析">Step1：题目简化&amp;粗略分析</h2>
<p>与我以往写的题解不同，这一篇题解的第一个部分不再是《题目描述》，而是《题目简化&amp;分析》，因为在我看来此题最大的障碍在于题目的理解。</p>
<ol>
<li>
<p>首先，让我们理解一下什么叫做“用同一账号连续发多个帖子”。这其中有个很重要的一点，这会影响到我们后续的做题，注意此处的“连续”，设想一个问题，如果我发的所有帖子是不连续的（也就是说我在几个账号上循环发帖），那么就不存在同一账号上的“连续的多个帖子”了。</p>
</li>
<li>
<p>其次，在理解了上一个问题之后再来看一下“该账号的安全指数会减小这两篇帖子安全指数的较小值”这句话做何理解（怎么感觉再讲阅读理解？）。其实很容易弄懂，这句话是指在同一账号中的连续帖子之间相邻连个帖子的最小值就是这个账号的风险，把这些值累加起来，第一篇帖子的安全系数减去累加起来的值就是这个账号的安全指数。</p>
</li>
</ol>
<h2 id="step2题目详细分析">Step2：题目详细分析</h2>
<p>在理解了第一部分的内容后就开始对题目进行一个较为深入的解析。</p>
<h3 id="step2_1关于安全指数的来源">Step2_1：关于安全指数的来源</h3>
<p>来源有二：其一，是本账号的第一篇帖子的安全指数。其二在后续发帖过程中所损失的安全指数。</p>
<h3 id="step2_2如何使安全指数最大化">Step2_2：如何使安全指数最大化</h3>
<ol>
<li>
<p>首先不难发现，总有一个账号的第一篇帖子是所有帖子的第一篇，应为所有帖子的的发帖顺序是固定的，只是在那个账号发事不固定的。</p>
</li>
<li>
<p>其次，根据 Step1_1 中提到的：“如果我发的所有帖子是不连续的（也就是说我在几个账号上循环发帖），那么就不存在同一账号上的‘连续的多个帖子’。”可以得出所有会损失安全值得操作会在第二个账号发了一个帖子后结束。</p>
</li>
<li>
<p>接下来，如果在用第二个账号发帖之后还有多余的账号，就可以用账号来发剩下帖子中价值最大的贴子以获取最大的收益。</p>
</li>
<li>
<p>最后一点，也是本题的关键：确定第二个账号发的第一个帖子是哪一篇。解决了这个问题，此题就结束了。</p>
</li>
</ol>
<h3 id="step2_3如何解决-step2_2_4-中所提到的问题">Step2_3：如何解决 Step2_2_4 中所提到的问题</h3>
<p>设想一个问题，如果前面帖子损失的安全指数已经大于了所有账号第一篇帖子中的最小值，那么我肯定会舍弃这个帖子然后减小前面帖子的损失。</p>
<p>这样的话我们就可以有效的解决 Step2_2_4 中的问题。</p>
<h3 id="代码分析">代码分析</h3>
<p>接下来，只讲我个人的做题方法</p>
<ol>
<li>
<p>先对所有相邻的贴子求一遍最小值，在对最小值求前缀和预处理。</p>
</li>
<li>
<p>对原来序列排序，找出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个最大的帖子（还有一个帖子是所有帖子中的第一个，在 Step2_2_1 中有所讲解，并且记录这些帖子中最靠前的是哪一篇，（记位置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>w</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">first\_where</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span></span></span></span> ）。</p>
</li>
<li>
<p>枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>w</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">first\_where</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span></span></span></span> 的每一个帖子作为第二个账号的第一篇帖子所获得的最大收益，求出答案</p>
</li>
</ol>
<h2 id="ac-code">AC code</h2>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

#define reg register
#define ll long long

using namespace std;

int Time;
int T;
int n, k;

struct Node{
	ll size;
	int where;
}passage[100000 + 10];

ll pre[100000 + 10];
ll pre_[100000 + 10];
ll d[100000 + 10];

bool cmp(Node x, Node y) {return x.size &gt; y.size;}

int main()
{
	scanf(&quot;%d&quot;, &amp;Time);
	scanf(&quot;%d&quot;, &amp;T);
	while(T--)
	{
		ll ans = 0, first = 0;
		ll Max = -1e9;
		ll value = 0;
		int first_where = 1e9;
		scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
		for (reg int i = 1; i &lt;= n; i++)
		{
			scanf(&quot;%d&quot;, &amp;passage[i].size);
			passage[i].where = i;
			d[i] = pre[i] = passage[i].size;
		}
		first = passage[1].size;
		for (reg int i = 1; i &lt; n; i++) pre[i] = min(passage[i].size, passage[i + 1].size);
		for (reg int i =1; i &lt; n; i++) pre[i] = pre[i] + pre[i - 1];
		for (reg int i = 3; i &lt;= n; i++) pre_[i] = pre[i - 2];
		sort(passage + 2, passage + n + 1, cmp);
		for (reg int i = 2; i &lt;= k; i++) 
			first_where = min(first_where, passage[i].where);
		for (reg int i = 2; i &lt;= k; i++) value += passage[i].size;
		Max = value + first - pre_[first_where];
		for (reg int i = 2; i &lt; first_where; i++)
			Max = max(Max, (first - pre_[i] + d[i] + value - passage[k].size));
		printf(&quot;%lld\n&quot;, Max);
	}
	return 0;
}
</code></pre>
<h2 id="后记">后记</h2>
<p>此篇题解写于 2021CSP 之前，在这里祝所有同学能在接下来的学习中跟进一步，考试中 rp++ ！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[闲人の题解 P7814]]></title>
        <id>https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p7814/</id>
        <link href="https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p7814/">
        </link>
        <updated>2021-11-20T03:22:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="p7814">P7814</h2>
<p><a href="https://www.luogu.com.cn/problem/P7814">题目传送门</a></p>
<h2 id="题目简述">题目简述</h2>
<ul>
<li>
<p>有两个由0和1组成的字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 。</p>
</li>
<li>
<p>其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 不是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的字串但是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 却是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的子序列。</p>
</li>
<li>
<p>找出一个满足要求得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 串并输出。</p>
</li>
<li>
<p>一共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> 组询问， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 串长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 串长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> , 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mi>m</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mo>∑</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1 \le n \le m , 1 \le \sum m \le 2 \times 10 ^ 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ul>
<h2 id="题目分析">题目分析</h2>
<p>首先我把这道题分为了两个部分：</p>
<ol>
<li>
<p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 长度为一和二时</p>
</li>
<li>
<p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的长度在三以上的时候。</p>
</li>
</ol>
<p>我们来分别讨论以上两种情况：</p>
<h3 id="长度为-1-或-2">长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></h3>
<p>显然， 如果长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时一定找不到一个满足条件的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 。<br>
再来讨论 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的情况，设想， 如果这两个数一个是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ， 一个是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ， 也不存在可行解， 事实上当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的长度和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的长度一样时也时无解的。 那么难道只要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 就都无解吗？其实不是， 如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 形如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>00</mn></mrow><annotation encoding="application/x-tex">00</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span></span></span></span> ，那 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 只要像 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>01...10</mn></mrow><annotation encoding="application/x-tex">01...10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">1</span><span class="mord">0</span></span></span></span> 就可以了。 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span></span></span></span> 时同理。</p>
<h3 id="长度在-3-以上">长度在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 以上</h3>
<ol>
<li>
<p>如果在原序列中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 都有， 就有一种比较妙的容易想到的方法， 比如现在的序列是这样的： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>01110101010</mn></mrow><annotation encoding="application/x-tex">01110101010</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span></span></span></span>  我们不妨将第一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 和后面所有的数分开来看，如果我在第一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 的后面一直添加和它不同的数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ， 那么后面的所有数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1110101010</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1110101010)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 和前面的那个新加的数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 一定组成不了原序列。所以成立！</p>
</li>
<li>
<p>那么新的问题出现了如果我的序列是这样的： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>011111111</mn></mrow><annotation encoding="application/x-tex">011111111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span> 会发现用上一个方法不行了，应为如果在第一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 后面加不同的数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时第一个数会和后面的数组成原序列， 俗话说特殊情况特殊处理， 我们不难想到从第二个数开始插入与后面的数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 不同的数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> ，就像这样： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>010...011111111</mn></mrow><annotation encoding="application/x-tex">010...011111111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span> 。好啦，现在这个问题也愉快的解决啦！</p>
</li>
</ol>
<h2 id="ac-code">AC Code</h2>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

const int N = 1e6;

int n, m;
char a[N];

inline int check(int l, int r)              //判断序列的成分， 全是0则返回0， 全是1则返回1， 如果都有则返回-1；
{
    bool one = false, zero = false;
    for (register int i = l; i &lt;= r; i++)
        if (one == true &amp;&amp; zero == true) return -1;
        else if (a[i] == '1') one = true;
        else zero = true;
    if (one == true &amp;&amp; zero == true) return -1;
    if (one == true &amp;&amp; zero == false) return 1;
    else return 0;
}

using namespace std;

int main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        cin &gt;&gt; a;
        int len = strlen(a);
        if (n == m || n == 0 || n == 1)        //特殊的无解情况
        {
            printf(&quot;-1\n&quot;);
            continue;
        }
        if(n == 2)                             //A长度时2的情况
        {
            if(a[0] == a[1])
            {
                printf(&quot;%c&quot;, a[0]);
                for (int i = 1; i &lt;= m - n; i++) printf(&quot;%c&quot;, ~a[0] + 98);
                printf(&quot;%c\n&quot;, a[len - 1]);
            }
            else printf(&quot;-1\n&quot;);
            continue;
        }
        int right = check(1, len - 1);
        if(right == 1 || right == 0)            //常规情况
        {
            printf(&quot;%c%c&quot;, a[0], a[1]);
            for (int i = 1; i &lt;= m - n; i++) printf(&quot;%c&quot;, ~a[1] + 98);
            for (int i = 2; i &lt;= len - 1; i++) printf(&quot;%c&quot;, a[i]);
            printf(&quot;\n&quot;);
            continue;
        }
        else
        {
            printf(&quot;%c&quot;, a[0]);
            for (int i = 1; i &lt;= m - n; i++) printf(&quot;%c&quot;, ~a[0] + 98);
            for (int i = 1; i &lt;= len - 1; i++) printf(&quot;%c&quot;, a[i]);
            printf(&quot;\n&quot;);
            continue;
        }
    }
    return 0;
}
</code></pre>
<h2 id="后记">后记</h2>
<p>此题主要在于思维， 对于代码的要求极低， 但是思维一定要打开。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[lxxy题解]]></title>
        <id>https://evrgardenviolet.github.io/post/lxxy-ti-jie/</id>
        <link href="https://evrgardenviolet.github.io/post/lxxy-ti-jie/">
        </link>
        <updated>2021-11-20T03:21:30.000Z</updated>
        <content type="html"><![CDATA[<p>大家好，我是搬题人闲人，这里，来讲一下这道题的正解</p>
<h2 id="题目描述">题目描述</h2>
<p>略</p>
<h2 id="难点">难点</h2>
<p>这道题我和三强讨论过后决定评一个 提高加/省选 的难度，因为此题的思维很重要，想明白了，一下就好了，想不明白就死活做不出来。</p>
<ol>
<li>首先是关于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 的求法，为什么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 可能好多人没有想懂，知道了也只是在打标时无意发现的（我是不会告诉你我就是这样做对的）。所以我在这里讲一下证明：<br>
我们先来看 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">numgcd(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 这个函数根据题目中的定义我们不难发现这其实是欧拉函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\varphi(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> ，那么根据 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\varphi(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 的性质我们可以知道两条性质：<br>
1： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">1 \sim x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 中与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的最大公约数为 1 的所有数的和等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⋅</mo><mi>φ</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x \cdot \varphi(x) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span><br>
2： 若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\varphi(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>(</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\varphi(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 互质，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>(</mo><mi>a</mi><mo>⋅</mo><mi>b</mi><mo>)</mo><mo>=</mo><mi>φ</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>⋅</mo><mi>φ</mi><mo>(</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\varphi(a \cdot b) = \varphi(a) \cdot \varphi(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span><br>
显然，这一道题我们要用到的是第一条性质。<br>
证明：<br>
$ \because gcd(a, b) = gcd(a, a - b)$<br>
$ \therefore $ 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 不互质的数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a - b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 成对出现，平均值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span><br>
故性质一成立。<br>
证毕。<br>
由此可以知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi><mo>⋅</mo><mi>φ</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">sumgcd(x) = x \cdot \varphi(x) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span><br>
又<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∵</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mn>2</mn><mo>⋅</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\because f(x) = \frac{2 \cdot sumgcd(x)}{numgcd(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∵</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">⋅</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mn>2</mn><mo>⋅</mo><mi>x</mi><mo>⋅</mo><mi>φ</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><mrow><mi>φ</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\therefore f(x) = \frac{2 \cdot x \cdot \varphi(x) / 2}{\varphi(x)} = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">⋅</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">⋅</span><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></li>
<li>在解决了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 的问题之后，我们还要考虑如何快速的求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>f</mi><mo>(</mo><mi>i</mi><msup><mo>)</mo><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">\sum_{i = 1}^{n}f(i)^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148818em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 的值。这里我介绍一种泛用性较高的，也是做简单的方法，我们找出所有询问当中最大的一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ，在计算这一组数据时就沿路记录其他的解的值，最后统一输出就可以了。</li>
</ol>
<p>最后附上代码：</p>
<h2 id="ac-code">AC Code</h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define  ll long long
#define reg register

using namespace std;

const int N = 1000100, MOD = 998244353;

ll T, k, n[N];
ll ans[N];

inline ll quick_power(ll a)
{
   ll r = 1, base = a;
   ll x = k;
   while (x != 0){
   	if (x &amp; 1 == 1)
       {
   		r *= base;
   		r %= MOD;	
   	}
   	base *= base;
   	base %= MOD;	
   	x = x &gt;&gt; 1;
   } 
   return r % MOD;
}


int main()
{
   cin &gt;&gt;  T &gt;&gt; k;
   ll Max = 0;
   for (reg int i = 1; i &lt;= T; i++)
   {
       scanf(&quot;%d&quot;, &amp;n[i]);
       if(Max &lt; n[i])
       {
           for (reg int j = Max + 1; j &lt;= n[i]; ++j) ans[j] = (ans[j - 1] + quick_power(j)) % MOD;
           Max = n[i];
       }
       printf(&quot;%d\n&quot;, ans[n[i]]);
   }
   return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[闲人の题解 P1834]]></title>
        <id>https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p1834/</id>
        <link href="https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p1834/">
        </link>
        <updated>2021-11-20T03:20:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<ul>
<li>
<p>1 ~ 9 的数用四则运算凑成 24。</p>
</li>
<li>
<p>满足答案字典序最小。</p>
</li>
<li>
<p>题目保证有解。</p>
</li>
</ul>
<h4 id="题目传送门"><a href="https://www.luogu.com.cn/problem/P1834">题目传送门</a></h4>
<h2 id="讲解">讲解</h2>
<h3 id="round1">Round1</h3>
<p>此题关键在于字典序。先让我们来想一想，什么情况下字典序.可以尽可能小？  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mo>(</mo><mn>3</mn><mo>∗</mo><mn>5</mn><mo>)</mo><mo>+</mo><mn>2</mn><mo>)</mo><mo>+</mo><mn>7</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(((3 * 5)+2)+7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span>  这是样例给出的答案。<br>
观察一下，为什么他要把三个括号放在前面？ 显然，因为“()”的 ASCII 码是运算符里（仅限于本题）最小的。所以如果我们可以把式子写成   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mo>(</mo><mi>A</mi><mi mathvariant="normal">opr</mi><mo>⁡</mo><mi>B</mi><mo>)</mo><mi mathvariant="normal">opr</mi><mo>⁡</mo><mi>C</mi><mo>)</mo><mi mathvariant="normal">opr</mi><mo>⁡</mo><mi>D</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(((A\operatorname{opr} B)\operatorname{opr} C)\operatorname{opr} D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mord mathrm">o</span><span class="mord mathrm">p</span><span class="mord mathrm">r</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mord mathrm">o</span><span class="mord mathrm">p</span><span class="mord mathrm">r</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mord mathrm">o</span><span class="mord mathrm">p</span><span class="mord mathrm">r</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span> （注：opr 指运算符）的形式就不需要额外考虑怎么加括号的事了！</p>
<h3 id="round2">Round2</h3>
<p>分析一下刚刚我们处理字典序的方法，不难发现其中的 BUG！如果遇上了 $ 5 5 5 5 $ 的情况显然用刚才的表达式是无法求出解的，而只能换成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mn>5</mn><mo>∗</mo><mn>5</mn><mo>)</mo><mo>−</mo><mo>(</mo><mn>5</mn><mi mathvariant="normal">/</mi><mn>5</mn><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">((5* 5)-(5/5))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">/</span><span class="mord">5</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 的形式。所以当我们遇到这样的情况，先看一下第一种情况行不行的通，行不通再用第二种方法。</p>
<h3 id="round3">Round3</h3>
<p>我们如何来比对那个式子的字典序最小呢？我们可以用一个 cmp 数组初始为“zzzzzzzzzzzzz”然后每搜到一个答案就把它替换掉。</p>
<h3 id="round4">Round4</h3>
<p>深搜的思路也比较简单，先枚举四张牌，在枚举运算符，然后把得到的数值递归到下一层，最后判断是否等于 24 即可。</p>
<h3 id="round5">Round5</h3>
<p>其他的细节会在代码注释里出现，这样方便同学们理解。</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
int src[5]; //面值
char opr[4] = {'+', '-', '*', '/'};
char out[15] = {'(', '(', '(', '\0', '\0', '\0', ')', '\0', '\0', ')', '\0', '\0', ')'};
//数字在（从“0”开始数）第3，5，8，11的位置 
//可以推出公式：除第1个数字在位置3外，第n个数字在3 * n - 1
//运算符同理：第n个运算符在3 * n - 2(符号只有三个)
char cmp[15] = &quot;zzzzzzzzzzzzz&quot;;  
bool u[5];
int calc(int a, int b, int cal)
{
    switch (cal)
    {
    case (0):
        return a + b;
    case (1):
        return a - b;
    case (2):
        return a * b;
    case (3):
        return a / b;
    default:
        return -1;
    }
}

void search_second(int d)		//第二种情况 
{
    int A, B;
    int sum;
    for (int a1 = 1; a1 &lt;= 4; a1++)
    {
        for (int a2 = 1; a2 &lt;= 4; a2++)
        {
            if (a2 == a1)
                continue;
            for (int a3 = 1; a3 &lt;= 4; a3++)
            {
                if (a3 == a1 || a3 == a2)
                    continue;
                for (int a4 = 1; a4 &lt;= 4; a4++) //24
                {
                    if (a4 == a1 || a4 == a2 || a4 == a3)
                        continue;
                    for (int i = 0; i &lt; 4; i++)
                    {
                        if (i == 3 &amp;&amp; src[a1] % src[a2] != 0)
                        {
                            continue;
                        }
                        for (int j = 0; j &lt; 4; j++)
                        {
                            if (j == 3 &amp;&amp; src[a3] % src[a4] != 0)
                            {
                                continue;
                            }
                            A = calc(src[a1], src[a2], i);
                            B = calc(src[a3], src[a4], j);

                            for (int q = 0; q &lt; 4; q++)
                            {
                                if (q == 3)
                                {
                                    if (A != 0 &amp;&amp; B != 0)
                                    {
                                        if (A % B != 0)
                                            continue;
                                    }
                                    else
                                        continue;
                                }

                                sum = calc(A, B, q);
                                if (sum == 24)
                                {
                                    int x1 = src[a1], x2 = src[a2], x3 = src[a3], x4 = src[a4];
                                    out[0] = '(';
                                    out[1] = '(';
                                    out[2] = x1 + '0';
                                    out[3] = opr[i];
                                    out[4] = x2 + '0';
                                    out[5] = ')';
                                    out[6] = opr[q];
                                    out[7] = '(';
                                    out[8] = x3 + '0';
                                    out[9] = opr[j];
                                    out[10] = x4 + '0';
                                    out[11] = ')';
                                    out[12] = ')';

                                    if (strcmp(out, cmp) &lt; 0)
                                    {
                                        strcpy(cmp, out);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return;
}

void search(int d, int sum)
{
    if (d &gt; 4)
    {
        if (sum == 24 &amp;&amp; strcmp(out, cmp) &lt; 0)
        {
            strcpy(cmp, out);
        }
        return;
    }
    for (int i = 1; i &lt;= 4; i++)
    {
        if (!u[i])
        {
            u[i] = 1;
            if (d == 1)
            {
                out[3] = char(src[i] + '0');
            }
            else
            {
                out[3 * d - 1] = char(src[i] + '0'); //放数字
            }
            for (int j = 0; j &lt; 4; j++)
            {
                int tmps = sum;
                if (j == 3 &amp;&amp; tmps % src[i] != 0)
                {
                    continue;
                }
                if (d == 1)
                {
                    search(d + 1, src[i]);
                    break;
                }
                tmps = calc(tmps, src[i], j); //计算当前能算出的数值
                out[3 * d - 2] = opr[j];      //放符号
                search(d + 1, tmps);          //下一个数
                out[3 * d - 2] = '\0';
            }
            if (d == 1)
            {
                out[3] = '\0';
            }
            else
            {
                out[3 * d - 1] = '\0';
            }
            u[i] = 0;
        }
    }
    return;
}
int main()
{
    for (int i = 1; i &lt;= 4; i++)
    {
        cin &gt;&gt; src[i];
    }
    search(1, 0);
    if (cmp[1] == 'z')						//如果第一种情况找不出就换第二种 
    {
        search_second(1);
    }
    puts(cmp);
    return 0;
}
</code></pre>
<h2 id="后记">后记</h2>
<p>此题最开始做的时候以为只用第一种情况就能过，然后发现事情不对，硬是把代码写了一百七十多行。暴力的地方可能有点臃肿，希望巨佬们要是有更好的方法可以私信提出。<br>
改了多次题解，一直LaTeX或英文少空格，不晓得是哪里的问题，望能再得到更详细的解释，谢。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[闲人の题解 P7522]]></title>
        <id>https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p7522/</id>
        <link href="https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p7522/">
        </link>
        <updated>2021-11-20T03:18:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="主要是一个巧妙的思路">主要是一个巧妙的思路</h1>
<p><a href="https://www.luogu.com.cn/problem/P7522">题目传送门</a></p>
<h2 id="题目分析">题目分析</h2>
<ul>
<li>
<p>有一堆数，然后那两个数，让一个去减另一个得到一个新数，然后放在这堆数里</p>
</li>
<li>
<p>求最后一个数最大。</p>
</li>
<li>
<p>$ 1\le n\le 3\times 10^{5} , \left |v_i  \right | \le 10^{9} $</p>
</li>
</ul>
<h2 id="思路">思路</h2>
<p>首先我们看几个样例：</p>
<p>3<br>
1 2 3<br>
ans $ = $ 4</p>
<p>4<br>
-4 5 -2 -3<br>
ans $ = $ 14</p>
<p>8<br>
2 0 2 1 0 4 2 3<br>
ans $ = $ 14<br>
可以发现第二个样例和第三个中ans的值是所有数的绝对值之和，但是第一个样例并非如次。于是我们自己造几个数据：<br>
6<br>
1 1 1 1 1 1<br>
ans $ = $ 4</p>
<p>6<br>
-1 1 1 1 1 1<br>
ans $ = $ 6</p>
<p>同样是六个数，为什么一个负数的差别使得一个答案是4，另一个是6。</p>
<ol>
<li>
<p>顺着这个思路我们可以对数列中的正负性分析出一下结论：</p>
</li>
<li>
<p>正数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo></mrow><annotation encoding="application/x-tex">-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span></span></span></span> 负数 可以得到一个最大值。</p>
</li>
<li>
<p>负数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo></mrow><annotation encoding="application/x-tex">-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span></span></span></span> 正数 可以得到一个最小值。</p>
</li>
<li>
<p>当且仅当数列中存在异号的数才可以把所有的负数转化成正数从而得到最大值。</p>
</li>
<li>
<p>如果数列中只有同号的数则 （1）若全是负数，则把最大值转化成正数，使数列中存在异号情况。（2）若全是正数，则把最小值转化成负数数，使数列中存在异号情况。</p>
</li>
<li>
<p>如果只有一个数，输出去就完了。</p>
</li>
</ol>
<p>那么我们的思路就出来了：</p>
<ol>
<li>
<p>如果异号，则输出所有数绝对值之和。</p>
</li>
<li>
<p>如果同号，就输出所有数绝对值之和减两次最大（小）值。</p>
</li>
<li>
<p>如果只有一个数，输出去。</p>
</li>
</ol>
<p>是不是超 <s>简单</s> 。</p>
<h2 id="ac代码">AC代码</h2>
<p>Code：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;

const int N = 1000010;

long long n, v[N];

int main(){
    cin &gt;&gt; n;
    long long num = 0, ans = 0, Min = 1e9 + 1, Max_ = -1e9 - 1;
    for(int i = 0; i &lt; n; i++){
        cin &gt;&gt; v[i];
        if(Max_ &lt; v[i]) Max_ = v[i];				//记录最大值 
        if(v[i] &lt;= 0) {
            num ++;
        }
        if(Min &gt; v[i]) Min = v[i];					//记录最小值 
    }
    if(n == 1) {									//判断只有一个数的情况 
        cout &lt;&lt; v[0]; return 0;
    }
    for(int i = 0; i &lt; n; i ++)						//所有数绝对值之和
    {
         ans += abs(v[i]);
    }
   if(num != 0 &amp;&amp; num != n){						//如果存在异号 
       cout &lt;&lt; ans;
   }
   else {											//如果存在同号 
       if(num == 0) cout &lt;&lt; ans - 2 * Min;			
       else cout &lt;&lt; ans - abs(2 * Max_);
   }
    return 0;
}
</code></pre>
<h2 id="后记">后记</h2>
<p>只是我唯一做出来的题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[闲人の题解 P3866]]></title>
        <id>https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p3866/</id>
        <link href="https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p3866/">
        </link>
        <updated>2021-11-20T03:17:41.000Z</updated>
        <content type="html"><![CDATA[<p>又是一道网络流的建图题<br>
<a href="https://www.luogu.com.cn/problem/P3866">题目传送门</a></p>
<h2 id="题目分析">题目分析</h2>
<ul>
<li>
<p>有一群敌人“0”，想要走出地图。</p>
</li>
<li>
<p>有一些障碍“-1”，在地图上。</p>
</li>
<li>
<p>你可以通过用炸药把一些地变为障碍，不过每一块地变成障碍所需的炸药不同，具体是这块地的数字，如“2”。</p>
</li>
<li>
<p>你现在要知道阻止敌人走出地图所用的最少炸药是多少。</p>
</li>
<li>
<p>对100%的数据，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo separator="true">,</mo><mi>N</mi><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">1 \le M,N \le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="思路">思路</h2>
<p>我们要割断敌人的路，断了的路不能走，又要使所用的炸药最少，想到了什么？<br>
对！ 最小割！<br>
又因为最大流=最小割。<br>
所以 建图+拆点+最大流 就是正解。</p>
<h2 id="亿点问题">亿点问题</h2>
<p>万恶的建图总是我们成功路上的绊脚石，所以我们应该如何建图呢？<br>
地图上唯一在在动的是敌人，而我们要阻止他到边界。每一个块地有一个值，代表我们那至少要用多少炸药把它变成障碍（要花费多少把流割断）。<br>
那么图的基本框架就出来了：</p>
<ol>
<li>
<p>把所有的点拆成两个，中间连起来的流量为这个点的数值。</p>
</li>
<li>
<p>构建一个超级源点，把所有的敌人的入点连起来。</p>
</li>
<li>
<p>把所有的点的出点连上旁边点的入点。</p>
</li>
<li>
<p>建一个超级汇点，把所有的边界点的出点连起来。</p>
</li>
</ol>
<p>PS.不过敌人和障碍都可以不连边，因为他们不能炸掉。</p>
<h2 id="代码">代码</h2>
<p>Code:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#define ll long long
using namespace std;

const int N = 100010, M = 2000010, INF = 1e8;

ll n, m, S, T;
ll head[N], ver[M], edge[M], next_[M], tot;
ll q[N], d[N], cur[N];
ll map[35][35];

ll min_(int x, int y) {
	if (x &lt; y) return x;
	return y;
}

//网络流连边 
void add(int x, int y, int z) {
	ver[tot] = y, edge[tot] = z, next_[tot] = head[x], head[x] = tot ++;
	ver[tot] = x, edge[tot] = 0, next_[tot] = head[y], head[y] = tot ++;
}

//网络流Dinic
bool bfs() {												
	int hh = 0, tt = 0;
	memset(d, -1, sizeof d);
	q[0] = S, d[S] = 0, cur[S] = head[S];
	while (hh &lt;= tt) {
		int t = q[hh++];
		for (int i = head[t]; ~i; i = next_[i]) {
			int ver_ = ver[i];
			if (d[ver_] == -1 &amp;&amp; edge[i]) {
				d[ver_] = d[t] + 1;
				cur[ver_] = head[ver_];						
				if (ver_ == T) return true;
				q[++ tt] = ver_;
			}
		}
	}
	return false;   
}

int find(ll u, ll limit) {									
	if (u == T) return limit;
   	ll flow = 0;
	for (int i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = next_[i]) {
		cur[u] = i;
		int ver_ = ver[i];
		if (d[ver_] == d[u] + 1 &amp;&amp; edge[i]) {
			int t = find(ver_, min_(edge[i], limit - flow));
			if (!t) d[ver_] = -1;
			edge[i] -= t, edge[i ^ 1] += t, flow += t;
		}
	}
	return flow;
}

ll dinic() {												 
	long long r = 0, flow;
	while (bfs()) while (flow = find(S, INF)) r += flow;
	return r;
} 


int main() {
	cin &gt;&gt; n &gt;&gt; m;
	memset(head, -1, sizeof head);																							//初始化表头 
	for(int i = 1; i &lt;= n; i ++){
		for(int j = 1; j &lt;= m; j ++){
			cin &gt;&gt; map[i][j];
		}
	}
	for(int i = 1; i &lt;= n; i ++){
		for(int j = 1; j &lt;= m; j ++){
			if(map[i][j] == -1) continue;																					//障碍 
			else if(map[i][j] == 0) add((i - 1) * m + j ,(i - 1) * m + j + n * m, INF), add(0, (i - 1) * m + j, INF);		//敌人 
			else add((i - 1) * m + j, (i - 1) * m + n * m + j, map[i][j]);													//自己的入点连出点 
			if(i &gt; 1 &amp;&amp; map[i - 1][j] != -1) add((i - 1) * m + n * m + j, (i - 1 - 1) * m + j,INF);							//内部点连四周 
			if(j &gt; 1 &amp;&amp; map[i][j - 1] != -1) add((i - 1) * m + n * m + j, (i - 1) * m + j - 1,INF);
			if(i &lt; n &amp;&amp; map[i + 1][j] != -1) add((i - 1) * m + n * m + j, (i) * m + j,INF);
			if(j &lt; m &amp;&amp; map[i][j + 1] != -1) add((i - 1) * m + n * m + j, (i - 1) * m + j + 1,INF);
			if(i == 1 || j == 1 || i == n || j == m) add((i - 1) * m + n * m + j, 2 * n * m + 1, INF);						//边界 
		}
	}
	S = 0;
	T = 2 * n * m + 1;
	cout &lt;&lt; dinic();
	return 0;
}
</code></pre>
<h2 id="后记">后记</h2>
<p>一些其他关于网络流的题：<br>
<a href="https://www.luogu.com.cn/problem/P2598">狼和羊的故事</a><br>
<a href="https://www.luogu.com.cn/problem/P2774">方格取数问题</a><br>
<a href="https://www.luogu.com.cn/problem/P2754">家园 / 星际转移问题</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[闲人の题解 P2065]]></title>
        <id>https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p2065/</id>
        <link href="https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p2065/">
        </link>
        <updated>2021-11-20T03:16:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一道网络流的题重在建图">一道网络流的题，重在建图</h1>
<p><a href="https://www.luogu.com.cn/problem/P2065">题目传送门</a></p>
<h2 id="题目分析">题目分析</h2>
<p>首先，我们简化一下题面：</p>
<ul>
<li>
<p>有两堆数。</p>
</li>
<li>
<p>一次只能在两堆中分别选一个数且不互质。</p>
</li>
<li>
<p>求最多能取几次。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">1 \le n,m\le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="错误解">错误解</h2>
<p>其实比较容易理解，所以我们首先想到了用二分做：</p>
<ol>
<li>
<p>如果一个蓝色数字和一个红色数字不互质，我们就把它们连起来。</p>
</li>
<li>
<p>然后用一个二分跑一遍，求出最大匹配。</p>
</li>
</ol>
<p>但是实际操作上是要T掉的，因为二分匹配有着 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 的时间复杂度，加上连线的时间是一定会T掉的。</p>
<h2 id="正解">正解</h2>
<p>然后啊，我就想到可以用网络流：</p>
<ol>
<li>
<p>因为蓝色数字和红色数字互质时才可以配对，所以可以看成蓝色的数字和红色的数字是通过它们共同的质因数连接起来的。</p>
</li>
<li>
<p>由于每一张牌只能用一次，所以每一条流的流量都为1。</p>
</li>
<li>
<p>我们把源点和每一个蓝色点连起来，把每一个红色点和汇点连起来，蓝色点和红色点由中间的质数点连起来。</p>
</li>
<li>
<p>最后跑一遍网络流就好了。</p>
</li>
</ol>
<p>其中在算质数点的时候，直接用试除法就可以了，不过感兴趣的同学可以了解一下Pollard's Rho算法。</p>
<p><a href="https://zhuanlan.zhihu.com/p/267884783">Pollard's Rho</a></p>
<p><s>(不是我写的)</s></p>
<h2 id="建图">建图</h2>
<p>接下来，还有一个问题需要解决，就是我们应该如何给点标号呢？</p>
<p>这里分享一种方法 ：</p>
<p>因为中间的质数点个数我们是事先不知道的，所以标号红点应该放在通过蓝点算质数点的操作之后。<br>
由此可得：</p>
<ol>
<li>
<p>源点为“0”号点，</p>
</li>
<li>
<p>蓝点编号为1到 blue，</p>
</li>
<li>
<p>质数点编号为 blue 到 blue + total，</p>
</li>
<li>
<p>红点编号为 blue + total 到 blue + total + red，</p>
</li>
<li>
<p>汇点编号为 blue + red + total + 1。</p>
</li>
</ol>
<p>下面是通过样例中第一个数据所建得图：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/rh9i74mf.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="1" loading="lazy"></figure>
<h2 id="代码">代码</h2>
<p>最后放上AC代码，希望可以帮助大家理解</p>
<p>Code:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

const int N = 1000010, M = 2000010, INF = 1e9;

long long head[N], edge[M], next_[M], ver[M], tot;
int  q[N], d[N], cur[N];
int n, m, S, T;
int red, blue, total;
int p[35500], b[35500]; 

int min_(int x, int y){
	if(x &lt; y) return x;
	return y;
}

void add(int x, int y, int z){
	ver[tot] = y, edge[tot] = z, next_[tot] = head[x], head[x] = tot ++;
	ver[tot] = x, edge[tot] = 0, next_[tot] = head[y], head[y] = tot ++;
}

void divide(int x, int e){								//用试除法找质数点并连接 
	
	int y = 0;
	for (int o = 2; o &lt;= sqrt(x); o ++){
		if(x % o == 0) {
			p[++ y] = o;
			while (x % o == 0) x /= o;
		}
	}
	if(x &gt; 1) p[++ y] = x;
	for(int o = 1;o &lt;= y; o ++) {
		if(b[p[o]] != 0) add(e, b[p[o]] + red + blue, 1);
		else b[p[o]] = ++ total, add(e, b[p[o]] + red + blue, 1);
	}
	return ;
}

void divide_2(int x,int e){
	int y = 0;
	for (int o = 2; o &lt;= sqrt(x); o ++){
		if(x % o == 0) {
			p[++ y] = o;
			while (x % o == 0) x /= o;
		}
	}
	if(x &gt; 1) p[++ y] = x;
	for(int o = 1;o &lt;= y; o ++) {
		if(b[p[o]] != 0) add(b[p[o]] + red + blue, e, 1);
	}
	return ;
}

bool bfs() {												
	int hh = 0, tt = 0;
	memset(d, -1, sizeof d);
	q[0] = S, d[S] = 0, cur[S] = head[S];
	while (hh &lt;= tt) {
		int t = q[hh++];
		for (int i = head[t]; ~i; i = next_[i]) {
			int ver_ = ver[i];
			if (d[ver_] == -1 &amp;&amp; edge[i]) {
				d[ver_] = d[t] + 1;
				cur[ver_] = head[ver_];						 
				if (ver_ == T) return true;
				q[++ tt] = ver_;
			}
		}
	}
	return false;   
}

int find(int u, int limit) {									 
	if(u == T) return limit;
   	int flow = 0;
	for (int i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = next_[i]) {
		cur[u] = i;
		int ver_ = ver[i];
		if (d[ver_] == d[u] + 1 &amp;&amp; edge[i]) {
			int t = find(ver_, min_(edge[i], limit - flow));
			if (!t) d[ver_] = -1;
			edge[i] -= t, edge[i ^ 1] += t, flow += t;
		}
	}
	return flow;
}

int dinic() {												 //dinic 跑网络流 
	int r = 0, flow;
	while (bfs()) while (flow = find(S, INF)) r += flow;
	return r;
}

int num;

int main(){
	cin &gt;&gt; num;
	
	for(int w = num; w &gt; 0; w --){
		tot = 0;
		memset(head, -1, sizeof head);
		memset(p, 0, sizeof p);
		memset(b, 0, sizeof b);
		total = 0;
		cin &gt;&gt; blue &gt;&gt; red;
		for(int j = 1;j &lt;= blue; j++){					//接点 
			add(0, j, 1);
		}
		for(int j = 1;j &lt;= blue; j++){
			int blue_;
			cin &gt;&gt; blue_;
			divide(blue_, j);
		}
		for(int i = 1; i &lt;= red; i++){
			int red_;
			cin &gt;&gt; red_;
			divide_2(red_, i + blue);
		}
		
		for(int i = 1; i &lt;= red; i++){
			add(i + blue, red + blue + total + 1, 1);
		}
		S = 0;
		T = blue + red + total + 1;
		cout &lt;&lt; dinic() &lt;&lt; endl;
	}
	return 0;
}

</code></pre>
<h2 id="后记">后记</h2>
<p>这道题我改了好久才过，怎么也没有想到是head数组没有初始化“-1”的原因，希望其他同学不要犯同样错误哦！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[闲人の题解 P7441]]></title>
        <id>https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p7441/</id>
        <link href="https://evrgardenviolet.github.io/post/xian-ren-noti-jie-p7441/">
        </link>
        <updated>2021-11-20T03:14:25.000Z</updated>
        <summary type="html"><![CDATA[<p><s>说实话，当我看到这道题时还有点懵。</s><br>
但是你静下来就会发现其实是一道数学思维的题。</p>
<p>我们可以把题抽象一下：</p>
<ul>
<li>有T组数据据。</li>
<li>每一组数据有两个等差数列，公差分别为x，y；</li>
<li>两个数列最大的一个数不大于K；</li>
</ul>
<h2 id="一些小问题">一些小问题</h2>
<p>细心地同学已经发现，我好像并没有考虑-K的情况。<br>
why？<br>
很简单</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∵</mo><mn>0</mn><mo>≤</mo><msub><mi>C</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>E</mi><mi>i</mi></msub><mo>≤</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">∵0\le C _i  ,E _i\le K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∵</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><msub><mi>C</mi><mi>i</mi></msub><mo>+</mo><mo>(</mo><mo>−</mo><mi>K</mi><mo>)</mo><mo separator="true">,</mo><msub><mi>E</mi><mi>i</mi></msub><mo>+</mo><mo>(</mo><mo>−</mo><mi>K</mi><mo>)</mo><mo>&lt;</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">∴C _i+(-K),E _i+(-K) &lt; K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span></p>
<p>so我们可以不用考虑-K的情况</p>
<h2 id="进入正解">进入正解</h2>
<h3 id="round1">Round1</h3>
<p>我们看看样例中的两个等差数列：<br>
2 4 6 8 10<br>
3 6 9<br>
因为每一片叶子和每一片雪花只能用一遍<br>
所以我们可以用其中一个数列中最小的数字去加另一个数列的最大数。<br>
为什么这样做?<br>
不难发现<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>+</mo><mn>10</mn><mo>=</mo><mn>13</mn></mrow><annotation encoding="application/x-tex">3 + 10 = 13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mo>+</mo><mn>8</mn><mo>=</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">6 + 8 = 14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn><mo>+</mo><mn>6</mn><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">9 + 6 = 15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span><br>
这是一个递增的关系<br>
有兴趣的小朋友可以证明一下为什么。</p>
<p>如果加起来不足K怎么办？<br>
那我们就用一个数列的第一个去加另一个数列的倒数第二个数。</p>
<h3 id="round-2">Round 2</h3>
<p>新的问题又出现：应该用哪一个数列的第一个数去加另一个数列的最后一个数呢？<br>
再看一下样例：<br>
2 4 6 8 10<br>
3 6 9<br>
可以发现我们最好情况下可以配对所有数字最少数列中的所有数，所以我们应该尽量把数字少的数列中的数字用完。</p>
<h3 id="round-3">Round 3</h3>
<p>那么思路就出来了：</p>
<ol>
<li>找出数列短的那一个。</li>
<li>用这个数列的第一个去加另一数列的最后一个数，如果大于等于K，则证明这个数列中的数都能匹配，直接输出此数列的数字个数。</li>
<li>如果2没有执行我们就用这个数列的第一个数去加另一个数列的倒数第二个数。</li>
</ol>
<h3 id="round-4-之亿点点问题">Round 4 之亿点点问题</h3>
<p>看看第二个样例是什么<br>
1<br>
0 0 1<br>
有“0”？？？？？？<br>
没错，如果有“0”，就会比较麻烦。</p>
<ol>
<li>如果两个公差都是“0”，那必然输出“0”，没说的</li>
<li>如果其中一个公差是“0”，我就还要判断另一个数列的最后一个数等不等于K，若是，就输出“1”。如不是，就只能输出“0”了</li>
</ol>
<h3 id="round-5">Round 5</h3>
<p>最后还是附上代码（代码的思路有一点点不一样，它说用数列数字多的那一个数列的最后一个数依次加另一数列的1,2,3...个数）</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define ll long long

using namespace std;

int find_ans(ll x,ll y,ll k){
	ll X_ = k / x, X = x, Y_2 = k % y;
	ll Y_ = k / y, Y_last = k - Y_2;
	for(ll i = Y_ ; i &gt;= 0; -- i){
		if((Y_last + x) &gt;= k){
			cout &lt;&lt; X_ &lt;&lt; endl;
			return 0;
		}
		else {
			x += X;
			X_ --;
		}
	}
	cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;
	return 0;
}
int main(){
	ll n;
	cin &gt;&gt; n;
	for(ll i = 1; i &lt;= n; i ++){
		ll a,b,c;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
		if(a == 0 || b == 0){
			if(a == 0 &amp;&amp; b == 0){
				cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;
			}
			else if(a == 0 &amp;&amp; c % b == 0){
				cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;
			}
			else if(b == 0 &amp;&amp; c % a == 0){
				cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;
			}
			else cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;
		}
		else{
		 	if(a &gt;= b){
			 	find_ans(a,b,c);
			 }
			else {find_ans(b,a,c);}
		}
	}
	return  0;
}
</code></pre>
<h2 id="后记">后记</h2>
<p>这篇题解中有些话可能有点绕，需要好好思考一下。<br>
因为是我第一篇发的题解（前面（一年前）发过只有代码的题解没有过） 也许有不足之处，还请随时指出。<br>
感谢阅览！</p>
]]></summary>
        <content type="html"><![CDATA[<p><s>说实话，当我看到这道题时还有点懵。</s><br>
但是你静下来就会发现其实是一道数学思维的题。</p>
<p>我们可以把题抽象一下：</p>
<ul>
<li>有T组数据据。</li>
<li>每一组数据有两个等差数列，公差分别为x，y；</li>
<li>两个数列最大的一个数不大于K；</li>
</ul>
<h2 id="一些小问题">一些小问题</h2>
<p>细心地同学已经发现，我好像并没有考虑-K的情况。<br>
why？<br>
很简单</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∵</mo><mn>0</mn><mo>≤</mo><msub><mi>C</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>E</mi><mi>i</mi></msub><mo>≤</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">∵0\le C _i  ,E _i\le K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∵</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><msub><mi>C</mi><mi>i</mi></msub><mo>+</mo><mo>(</mo><mo>−</mo><mi>K</mi><mo>)</mo><mo separator="true">,</mo><msub><mi>E</mi><mi>i</mi></msub><mo>+</mo><mo>(</mo><mo>−</mo><mi>K</mi><mo>)</mo><mo>&lt;</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">∴C _i+(-K),E _i+(-K) &lt; K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span></p>
<p>so我们可以不用考虑-K的情况</p>
<h2 id="进入正解">进入正解</h2>
<h3 id="round1">Round1</h3>
<p>我们看看样例中的两个等差数列：<br>
2 4 6 8 10<br>
3 6 9<br>
因为每一片叶子和每一片雪花只能用一遍<br>
所以我们可以用其中一个数列中最小的数字去加另一个数列的最大数。<br>
为什么这样做?<br>
不难发现<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>+</mo><mn>10</mn><mo>=</mo><mn>13</mn></mrow><annotation encoding="application/x-tex">3 + 10 = 13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mo>+</mo><mn>8</mn><mo>=</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">6 + 8 = 14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn><mo>+</mo><mn>6</mn><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">9 + 6 = 15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span><br>
这是一个递增的关系<br>
有兴趣的小朋友可以证明一下为什么。</p>
<p>如果加起来不足K怎么办？<br>
那我们就用一个数列的第一个去加另一个数列的倒数第二个数。</p>
<h3 id="round-2">Round 2</h3>
<p>新的问题又出现：应该用哪一个数列的第一个数去加另一个数列的最后一个数呢？<br>
再看一下样例：<br>
2 4 6 8 10<br>
3 6 9<br>
可以发现我们最好情况下可以配对所有数字最少数列中的所有数，所以我们应该尽量把数字少的数列中的数字用完。</p>
<h3 id="round-3">Round 3</h3>
<p>那么思路就出来了：</p>
<ol>
<li>找出数列短的那一个。</li>
<li>用这个数列的第一个去加另一数列的最后一个数，如果大于等于K，则证明这个数列中的数都能匹配，直接输出此数列的数字个数。</li>
<li>如果2没有执行我们就用这个数列的第一个数去加另一个数列的倒数第二个数。</li>
</ol>
<h3 id="round-4-之亿点点问题">Round 4 之亿点点问题</h3>
<p>看看第二个样例是什么<br>
1<br>
0 0 1<br>
有“0”？？？？？？<br>
没错，如果有“0”，就会比较麻烦。</p>
<ol>
<li>如果两个公差都是“0”，那必然输出“0”，没说的</li>
<li>如果其中一个公差是“0”，我就还要判断另一个数列的最后一个数等不等于K，若是，就输出“1”。如不是，就只能输出“0”了</li>
</ol>
<h3 id="round-5">Round 5</h3>
<p>最后还是附上代码（代码的思路有一点点不一样，它说用数列数字多的那一个数列的最后一个数依次加另一数列的1,2,3...个数）</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define ll long long

using namespace std;

int find_ans(ll x,ll y,ll k){
	ll X_ = k / x, X = x, Y_2 = k % y;
	ll Y_ = k / y, Y_last = k - Y_2;
	for(ll i = Y_ ; i &gt;= 0; -- i){
		if((Y_last + x) &gt;= k){
			cout &lt;&lt; X_ &lt;&lt; endl;
			return 0;
		}
		else {
			x += X;
			X_ --;
		}
	}
	cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;
	return 0;
}
int main(){
	ll n;
	cin &gt;&gt; n;
	for(ll i = 1; i &lt;= n; i ++){
		ll a,b,c;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
		if(a == 0 || b == 0){
			if(a == 0 &amp;&amp; b == 0){
				cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;
			}
			else if(a == 0 &amp;&amp; c % b == 0){
				cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;
			}
			else if(b == 0 &amp;&amp; c % a == 0){
				cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;
			}
			else cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;
		}
		else{
		 	if(a &gt;= b){
			 	find_ans(a,b,c);
			 }
			else {find_ans(b,a,c);}
		}
	}
	return  0;
}
</code></pre>
<h2 id="后记">后记</h2>
<p>这篇题解中有些话可能有点绕，需要好好思考一下。<br>
因为是我第一篇发的题解（前面（一年前）发过只有代码的题解没有过） 也许有不足之处，还请随时指出。<br>
感谢阅览！</p>
<!-- more -->
]]></content>
    </entry>
</feed>